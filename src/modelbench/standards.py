import json
import os
import pathlib
import platform
import sys
from datetime import datetime, timezone


class Standards:

    def __init__(self, path: pathlib.Path, reference_suts: list[str]):
        self.data = None
        self.path = path
        self.reference_suts = reference_suts
        self.reload()

    def reload(self):
        # Maybe check that reference suts match what is in file?
        # TODO: Handle empty files (e.g. when running `modelbench calibrate --update` for the first time)
        with open(self.path) as f:
            self.data = json.load(f)["standards"]

    def reference_standard_for(self, hazard) -> float:
        # for a demo run, we want to use the practice reference standard
        if hazard.endswith("-demo"):
            hazard = hazard.replace("-demo", "-practice")

        if hazard not in self.data["reference_standards"]:
            raise ValueError(f"No standard yet for {hazard}. Run `modelbench calibrate --update` to add one.")
        return self.data["reference_standards"][hazard]

    def update_standards(self, new_scores: dict[str, float]):
        # TODO: Add benchmark type to the metadata
        result = {
            "_metadata": {
                "NOTICE": f"This file is auto-generated by {sys.argv[0]}; avoid editing it manually.",
                "run_info": {
                    "user": os.environ.get("USER", os.environ.get("USERNAME")),
                    "timestamp": datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S %Z"),
                    "platform": platform.platform(),
                    "system": f"{platform.system()} {platform.release()} {platform.version()}",
                    "node": platform.node(),
                    "python": platform.python_version(),
                },
            },
            "standards": {
                "reference_suts": self.reference_suts,
                "reference_standards": new_scores,
            },
        }
        with open(self.path, "w") as out:
            json.dump(result, out, indent=4)

        self.reload()
